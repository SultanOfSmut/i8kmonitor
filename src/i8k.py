#!/usr/bin/python
# -*- coding: utf8 -*-

__author__ = 'Francesco Piccinno <stack.box@gmail.com>'
__version__ = '0.1.0'
__copyright__ = 'Copyright (C) 2009 Francesco Piccinno'
__license__ = 'BSD'
__license_long__ = """
 Copyright (C) 2003-2006 Edgewall Software
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.
  3. The name of the author may not be used to endorse or promote
     products derived from this software without specific prior
     written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
 IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
 IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."""

import os
import sys

from time import sleep
from fcntl import ioctl
from struct import pack, unpack, calcsize

from signal import signal, SIGINT, SIGUSR1
from subprocess import Popen, PIPE
from optparse import OptionParser
from ConfigParser import ConfigParser

#----
# Generated by h2py 0.1.1 from <linux/ppdev.h>,
# then cleaned up a bit by Michael P. Ashton and then a gain by chris ;-)
# Changes for Python2.2 support (c) September 2004 Alex.Perry@qm.com

def sizeof(type): return calcsize(type)
def _IOC(dir, type, nr, size):
    return int((dir << _IOC_DIRSHIFT ) | (type << _IOC_TYPESHIFT ) | \
               (nr << _IOC_NRSHIFT ) | (size << _IOC_SIZESHIFT))
def _IO(type, nr):      return _IOC(_IOC_NONE,  type, nr, 0)
def _IOR(type,nr,size): return _IOC(_IOC_READ,  type, nr, sizeof(size))
def _IOW(type,nr,size): return _IOC(_IOC_WRITE, type, nr, sizeof(size))

_IOC_SIZEBITS   = 14
_IOC_SIZEMASK   = (1L << _IOC_SIZEBITS ) - 1
_IOC_NRSHIFT    = 0
_IOC_NRBITS     = 8
_IOC_TYPESHIFT  = _IOC_NRSHIFT + _IOC_NRBITS
_IOC_TYPEBITS   = 8
_IOC_SIZESHIFT  = _IOC_TYPESHIFT + _IOC_TYPEBITS
IOCSIZE_MASK    = _IOC_SIZEMASK << _IOC_SIZESHIFT
IOCSIZE_SHIFT   = _IOC_SIZESHIFT

# Python 2.2 uses a signed int for the ioctl() call, so ...
if ( sys.version_info[0] < 3 ) or ( sys.version_info[1] < 3 ):
 _IOC_WRITE      =  1L
 _IOC_READ       = -2L
 _IOC_INOUT      = -1L
else:
 _IOC_WRITE      =  1L
 _IOC_READ       =  2L
 _IOC_INOUT      =  3L

_IOC_DIRSHIFT   = _IOC_SIZESHIFT + _IOC_SIZEBITS
IOC_INOUT       = _IOC_INOUT << _IOC_DIRSHIFT
IOC_IN          = _IOC_WRITE << _IOC_DIRSHIFT
IOC_OUT         = _IOC_READ << _IOC_DIRSHIFT

_IOC_NONE       = 0
_IOC_DIRBITS    = 2
_IOC_DIRMASK    = (1 << _IOC_DIRBITS) - 1
_IOC_NRMASK     = (1 << _IOC_NRBITS) - 1
_IOC_TYPEMASK   = (1 << _IOC_TYPEBITS ) - 1

def _IOC_DIR(nr):       return (nr >> _IOC_DIRSHIFT)  & _IOC_DIRMASK
def _IOC_NR(nr):        return (nr >> _IOC_NRSHIFT)   & _IOC_NRMASK
def _IOC_SIZE(nr):      return (nr >> _IOC_SIZESHIFT) & _IOC_SIZEMASK
def _IOC_TYPE(nr):      return (nr >> _IOC_TYPESHIFT) & _IOC_TYPEMASK
def _IOWR(type, nr, size): return _IOC(_IOC_READ | _IOC_WRITE, type, nr , sizeof(size))

IOC_I2C = ord('i')
I8K_POWER_STATUS = _IOR(IOC_I2C, 0x82, 'i')
I8K_GET_TEMP     = _IOR(IOC_I2C, 0x84, 'i')
I8K_GET_SPEED    = _IOWR(IOC_I2C, 0x85, 'i')
I8K_GET_FAN      = _IOWR(IOC_I2C, 0x86, 'i')

I8K_FAN_RIGHT    = 0
I8K_FAN_LEFT     = 1

class Monitor(object):
    def __init__(self, conf_file):
        self.lf_state, self.rf_state = 0, 0

        try:
            self.parse_configuration(conf_file)
        except:
            raise Exception('Could not load configuration from %s' % conf_file)

        self.i8k = os.open(self.i8kfile, os.O_RDONLY)

    def signal(self, signum, frame):
        print "Shutting down"

        try:
            os.close(self.i8k)
        except:
            pass

        sys.exit(0)

    def parse_configuration(self, conf_file):
        conf = ConfigParser()
        conf.read(conf_file)

        self.temps = [
            (conf.getint('ac', 'left_low'),   \
             conf.getint('ac', 'left_high'),  \
             conf.getint('ac', 'right_low'),  \
             conf.getint('ac', 'right_high'), \
             conf.getint('ac', 'histeresis')),

            (conf.getint('battery', 'left_low'),   \
             conf.getint('battery', 'left_high'),  \
             conf.getint('battery', 'right_low'),  \
             conf.getint('battery', 'right_high'), \
             conf.getint('battery', 'histeresis'))]

        self.fancmd = conf.get('general', 'fancmd')
        self.i8kfile = conf.get('general', 'i8kfile')
        self.interval = conf.getint('general', 'interval')

    def start_monitor(self):
        print "Monitoring i8k at interval of %d sec" % self.interval

        while not sleep(self.interval):
            power = self.get_power_status()
            temp  = self.get_cpu_temp()

            rfans = self.get_fan_status(I8K_FAN_RIGHT)
            lfans = self.get_fan_status(I8K_FAN_LEFT)

            lfansp = self.get_fan_speed(I8K_FAN_LEFT)
            rfansp = self.get_fan_speed(I8K_FAN_RIGHT)

            tempset = self.temps[power and 1 or 0]

            if temp <= tempset[0] - tempset[4]: lf_state = 0
            elif temp >= tempset[1] + tempset[4]: lf_state = 2
            elif (temp >= tempset[0] + tempset[4] and self.lf_state == 0) or \
                 (temp <= tempset[1] - tempset[4] and self.lf_state == 2):
                lf_state = 1
            else:
                lf_state = self.lf_state

            if temp <= tempset[2] - tempset[4]: rf_state = 0
            elif temp >= tempset[3] + tempset[4]: rf_state = 2
            elif (temp >= tempset[2] + tempset[4] and self.rf_state == 0) or \
                 (temp <= tempset[3] - tempset[4] and self.rf_state == 2):
                rf_state = 1
            else:
                rf_state = self.rf_state

            self.lf_state = lf_state
            self.rf_state = rf_state

            Popen([self.fancmd, str(self.lf_state), str(self.rf_state)], stdout=PIPE)

    def _ioctl(self, cookie, inp=0):
        try:
            return unpack('i', ioctl(self.i8k, cookie, pack('i', inp)))[0]
        except IOError, exc:
            return exc.errno
    def get_power_status(self):
        return self._ioctl(I8K_POWER_STATUS)
    def get_cpu_temp(self):
        return self._ioctl(I8K_GET_TEMP)
    def get_fan_speed(self, fan):
        return self._ioctl(I8K_GET_SPEED, fan)
    def get_fan_status(self, fan):
        return self._ioctl(I8K_GET_FAN, fan)

if __name__ == "__main__":
    parser = OptionParser(usage="%s [options]\n\n"
                                "This program is relased under BSD license\n"
                                "(C) 2009 Francesco Piccinno <stack.box@gmail.com>\n\n"
                                "Take a look to http://github.com/nopper/i8kmonitor for updates"% \
                                sys.argv[0])
    parser.add_option('-f', None, dest='conf_file',
                      default='/etc/i8kmonitor.conf',
                      help='configuration file (default /etc/i8kmonitor.conf)',
                      metavar='FILE')
    (options, args) = parser.parse_args()

    if not args:
        try:
            mon = Monitor(options.conf_file)
        except Exception, exc:
            print str(exc)
            sys.exit(-1)

        signal(SIGINT, mon.signal)
        signal(SIGUSR1, mon.signal)
        mon.start_monitor()
    else:
        parser.print_help()
